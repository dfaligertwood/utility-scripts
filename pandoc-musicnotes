#!/usr/bin/env python
from pandocfilters import RawInline, walk, stringify, toJSONFilter, Para, Note

power_symbol = '+'
seperator_symbol = ':'
string_keys = ['Str', 'Code', 'Math', 'LineBreak', 'Space', 'RawInline']
other_keys = ( ['Plain', 'Para', 'CodeBlock', 'RawBlock', 'BlockQuote',
                'OrderedList', 'BulletList', 'DefinitionList', 'Header',
                'HorizontalRule', 'Table', 'Div', 'Null', 'Emph', 'Strong',
                'Strikeout', 'Superscript', 'Subscript', 'SmallCaps', 'Quoted',
                'Cite', 'Link', 'Image', 'Note', 'Span'] )

"""
Does annotation stuff. For use with edNotes.sty.
HORRIFICALLY FRAGILE HORRIFICALLY HACKY DO NOT USE
ONCE PANDOC IMPLEMENTS A PROPER METHOD FOR FILTERING
NOTES.
"""

class WalkFilter:
    def __init__(self):
        self.divider = True
        self.divider_space = True
        self.powersym = True
        self.powersym_space = True
    def filter_latex(self, key, val, fmt, meta):
        if key == 'Para':
            return walk(val, self.filter_latex, "", {})
        elif self.powersym and val == power_symbol:
            self.powersym = False
            return []
        elif self.powersym_space and key == 'Space':
            self.powersym_space = False
            return []
        elif self.divider and val == seperator_symbol:
            self.divider = False
            return [latexInline('}{')]
        elif self.divider_space and not self.divider and key == 'Space':
            self.divider_space = False
            return []
    def filter_lemma(self, key, val, fmt, meta):
        if key == 'Para':
            return walk(val, self.filter_lemma, "", {})
        elif self.powersym and val == power_symbol:
            self.powersym = False
            return []
        elif self.powersym_space and key == 'Space':
            self.powersym_space = False
            return []
        elif self.divider and val == seperator_symbol:
            self.divider = False
            return []
        elif not self.divider:
            return []
    def filter_contents(self, key, val, fmt, meta):
        if key == 'Para':
            return [Para(walk(val, self.filter_contents, "", {}))]
        if self.divider and val == seperator_symbol:
            self.divider = False
            return []
        elif self.divider:
            return []
        elif self.divider_space and not self.divider and key == 'Space':
            self.divider_space = False
            return []

def latexInline(s):
    return RawInline('latex', s)

def parse(key, val, fmt, meta):
    if key == 'Note':
        contents = stringify(val)
        if contents[0] == power_symbol:
            if fmt == 'latex':
                arguments = WalkFilter().filter_latex
                return ([latexInline('\\Bnote{')] +
                        walk(val, arguments, "", {}) +
                        [latexInline('}')])
            else:
                lemma = WalkFilter().filter_lemma
                contents = WalkFilter().filter_contents
                return (walk(val, lemma, "", {}) +
                        [Note(walk(val, contents, "", {}))])


if __name__ == "__main__":
  toJSONFilter(parse)
